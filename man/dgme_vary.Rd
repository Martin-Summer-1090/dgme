% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dgme_vary.R
\name{dgme_vary}
\alias{dgme_vary}
\title{Generate a Family of Economies for Comparative Statics}
\usage{
dgme_vary(
  base,
  ...,
  grid_type = c("cross", "parallel"),
  label_prefix = NULL,
  validate = TRUE
)
}
\arguments{
\item{base}{A \code{dgme_params} object (the reference economy).}

\item{...}{Named arguments specifying which parameters to vary and
their values.  For scalar parameters (\code{q}, \code{rho},
\code{eta}, \code{S}), supply a numeric vector.  For vector or
matrix parameters (\code{m}, \code{alpha}, \code{e}, \code{m_S},
\code{g_shares}), supply a list of vectors/matrices.}

\item{grid_type}{Character.  \code{"cross"} (default) forms the Cartesian
product of all grids; \code{"parallel"} steps through them in lockstep.}

\item{label_prefix}{Character or \code{NULL}.  Prefix for auto-generated
labels.  Defaults to the base economy's label.}

\item{validate}{Logical.  If \code{TRUE} (default), each generated
economy is validated via \code{.validate_dgme_params()}.  Set to
\code{FALSE} to skip validation for speed on large grids.}
}
\value{
An S3 object of class \code{dgme_vary}, which is a list with:
\describe{
\item{\code{base}}{The original \code{dgme_params} object.}
\item{\code{varied}}{Character vector of parameter names being varied.}
\item{\code{grid_type}}{The grid type used.}
\item{\code{grid}}{A data frame describing parameter combinations.}
\item{\code{economies}}{A list of \code{dgme_params} objects (the
alternatives; does \emph{not} include the base).}
\item{\code{n}}{Integer: number of alternative economies.}
}
}
\description{
Given a base \code{dgme_params} object (from \code{\link{dgme_parametrize}}),
produce a list of alternative economies in which one or more parameters
vary across a specified grid while all other parameters remain fixed.
The base economy is stored in the result for comparison but is \emph{not}
duplicated in the list of alternatives.
}
\section{Design and usage}{

\code{dgme_vary} implements the comparative-statics step of the
modelling pipeline:
\preformatted{
  parametrize -> vary -> solve each -> compare
}

The simplest use is a single alternative economy:
\preformatted{
  dgme_vary(base, q = 0.5)
}
which produces one economy identical to \code{base} except with
\eqn{q = 0.5}.  Supply a vector for a sweep:
\preformatted{
  dgme_vary(base, q = seq(0.3, 0.9, 0.1))
}

The function supports three modes of variation:
\describe{
\item{\strong{Single parameter.}}{
Vary one scalar or vector parameter.  The number of alternative
economies equals the number of values supplied.
}
\item{\strong{Multiple parameters (cross product).}}{
With \code{grid_type = "cross"} (the default), the function forms
the full Cartesian product of all grids.
Example: \code{dgme_vary(base, q = c(0.5, 0.7), S = c(0, 5, 10))}
produces \eqn{2 \times 3 = 6} alternative economies.
}
\item{\strong{Multiple parameters (parallel).}}{
With \code{grid_type = "parallel"}, grids are stepped through
in lockstep (all must have the same length).
}
}
}

\section{Varying non-scalar parameters}{

Parameters that are vectors (\code{m}, \code{alpha}, \code{m_S},
\code{g_shares}) or matrices (\code{e}) must be varied by supplying
a \strong{list} of values, where each element has the same shape as
the original parameter:
\preformatted{
  dgme_vary(base, m = list(c(0.4, 1.8), c(1, 1), c(3, 0.5)))
}
}

\section{Accessing results}{

The base economy is available as \code{result$base}.  Alternative
economies are accessed via \code{result[[i]]}.  A typical downstream
workflow:
\preformatted{
  eq_base <- dgme_solve(family$base)
  eq_alt  <- dgme_solve(family[[1]])
}
}

\examples{
base <- dgme_parametrize("paper_example_1")

# Single alternative (change q from 0.6 to 0.5)
alt <- dgme_vary(base, q = 0.5)
alt$base$q   # 0.6  (original)
alt[[1]]$q   # 0.5  (alternative)

# Sweep over bond price
fam <- dgme_vary(base, q = seq(0.3, 0.9, by = 0.1))
print(fam)

# Cross product of q and S (requires Variant 2 base)
base_v2 <- dgme_parametrize("paper_example_1", rho = 0.2, eta = 0.5, S = 5)
fam_qs <- dgme_vary(base_v2, q = c(0.5, 0.7), S = c(0, 5, 10))

# Vary money endowments (non-scalar)
fam_m <- dgme_vary(base, m = list(c(0.4, 1.8), c(1, 1), c(3, 3)))

# Parallel variation (lockstep)
fam_par <- dgme_vary(base, q = c(0.4, 0.6, 0.8),
                     m = list(c(0.2, 1), c(0.4, 1.8), c(1, 3)),
                     grid_type = "parallel")
}
